(let-many
    (
        (first  (lambda x (lambda y x))) ; first = true
        (second (lambda x (lambda y y))) ; second = false
        (cons   (lambda x (lambda y (lambda f (f x y)))))
        (fst    (lambda p (p first)))
        (snd    (lambda p (p second)))
        (head fst)
        (tail snd)
        (if
            (lambda cond
                (lambda ifTrue (lambda ifFalse (cond ifTrue ifFalse)))))
        (map (lambda fn (lambda lst (cons (fn (fst lst)) (map fn (snd lst))))))
        (empty? (lambda lst (eq? 0 (length lst))))
        (length (lambda lst ((empty? lst) 0 (+ 1 (length (snd lst))))))
        (nth (lambda n (lambda lst (((eq? n 0) (head lst) (nth (- n 1) (tail lst)))))))
    )

    (let-many
        (
            (fact (lambda n ((eq? n 1) 1 (* n (fact (- n 1))))))
        )
        (fact 5)
    )
)

; (letrec fact
;     (lambda n (if (eq? n 1) 1 (* n (fact (- n 1)))))
;     (fact 5))

; (let Z
;     (lambda f
;         (
;             (lambda x (f (lambda v (x x v))))
;             (lambda x (f (lambda v (x x v))))
;         )
;     )
;     (
;         let fact (Y (lambda fact (lambda n (
;             (= n 1) 1 (* n (fact (- n 1)))
;         )))) (fact 5)
;     )
; )

; Z combinator
; (lambda f
;     (
;         (lambda x (f (lambda v (x x v))))
;         (lambda x (f (lambda v (x x v))))
;     )
; )